---
title: "Replicate model"
format: html
editor: visual
---

```{r}
#| label: setup
#| message: false
#| warning: false

# mandatory setup for working with macpan and stan
# - - - - - - - - - - - - - - - - - - - - - - - - - - - 
library(McMasterPandemic)
# source(here::here("R", "tmbstan_tools.R")) # some custom tools for connecting McMasterPandemic and Stan, they're documented fully in that file
source('../R/tmbstan_tools.R')
setup_stan() # some required set up for using Stan with McMasterPandemic
library(rstan) # for additional R Stan tools
library(dplyr)
library(tidyr)
library(here)
library(readr)
library(ggplot2)
library(ggpubr)

theme_set(
  theme_bw(base_size = 16)
)

fig <- list()
```

```{r}
#| label: ome functions used
# Function to plot the simulation ------------------
plot_sim = function(model, sim_result, title){
  (sim_result
   # drop any columns where a flow rate is returned
   %>% select(-matches("to"))
   # switch to long form for ease of use with ggplot
   %>% pivot_longer(-Date, names_to = "State", values_to = "Population")
   # sort state into a factor variable to enforce legend ordering based on
   # flow through the model
   %>% mutate(State = factor(State, 
                             levels = order_vars(model)))
   %>% ggplot(aes(x = Date, y = Population, colour = State))
   + geom_line(linewidth = 1.25)
   + labs(title = title)
   + theme(
     axis.title.x = element_blank(),
     legend.justification = c(1,1),
     legend.position = c(1,1),
     legend.background = element_rect(fill = NA),
     legend.key = element_rect(fill = NA)
   )
)
}

# FUnction to plot the ensemble ------------
plot_ensemble <- function(ens, obs, title = 'Incidence over time', subtitle = ''){
  value_type_labels <- c("Model fit", "Observed data")
  
  df = (ens
    %>% filter(var == "incidence")
    %>% mutate(value_type = value_type_labels[1])
    %>% bind_rows(
      obs %>% mutate(value_type = value_type_labels[2])
    )
  )
  
  colour_palette = c("dodgerblue", "black")
  names(colour_palette) = value_type_labels
  
  (ggplot(df, aes(x = date))
    # observed points
    + geom_point(
      data = df %>% filter(value_type == value_type_labels[2]),
      mapping = aes(y = value, colour = value_type), 
      shape = 1, size = 2
    )
    # simulation from fitted model
    + geom_ribbon(
      data = df %>% filter(value_type == value_type_labels[1]),
      mapping = aes(ymin = lwr, ymax = upr,
                    fill = value_type), alpha = 0.3
    )
    + geom_line(
      data = df %>% filter(value_type == value_type_labels[1]),
      mapping = aes(y = value, colour = value_type),
      linewidth = 1.25
    )
    + scale_colour_manual(values = colour_palette,
                          limits = value_type_labels)
    + scale_fill_manual(values = colour_palette,
                        limits = value_type_labels)
    + labs(title = title, subtitle = subtitle)
    + guides(
    color =
        guide_legend(override.aes = list(
          shape = c(NA, 1),
          linewidth = c(1.25, NA),
          fill = c(colour_palette[[1]], NA))
      )
    )
    + theme(
      axis.title = element_blank(),
      legend.title = element_blank(),
      legend.justification = c(0,1),
      legend.position = c(0,1),
      legend.background = element_rect(fill = NA),
      legend.key = element_rect(fill = NA)
    )
  )
}
```


# Read Case data

```{r}
#| label: data
#| message: false

cases = read_csv('../data/fitting.csv') # read the cases
# Transform the cases to match format for the model
obs <- cases %>% 
  mutate(
    date = as.Date(date), # convert to date
    var = 'incidence' # add a variable for the name of sim output
  ) %>% 
  select(date, var, value = new_cases) # order the variables to match the format
```


# Setting up the McMaster model

```{r}
#| label: Main model parameters
# This is a list of the main parameters for the model
pars <- list(
  pop = 2e9, # Population size
  beta = 0.7,
  log_m = -1,
  log_sd = 0.5
)
```


The next chink just runs the model with specified parameters

```{r}
#| label: state-and-params

# initial state, in units of individuals
state = c(
  # S = 2000,
  S = pars$pop,
  E = 0, 
  I = 1, 
  R = 0
)

# parameters
params = c(
  beta = pars$beta,
  N = sum(state),
  alpha = 0.05,
  gamma = 0.06
)
# Set the dates ---------------
# start and end dates specified as strings,

start_date = range(obs$date)[1] - 1
end_date = range(obs$date)[2]

# start_date = "2020-03-01"
# end_date = "2020-05-01"

# Model specification ---------
seir = flexmodel(
  params = params,
  state = state,
  start_date = start_date,
  end_date = end_date,
  do_hazard = TRUE # an option to ensure computations are stable when any of the state variables approach zero (keep this switched on!)
)

## Add the rates ----------
seir = (
  seir
  %>% add_rate(
    "S", # from compartment S
    "E", # to compartment I
    ~ (1/N) * (beta) * (I) # expression for the flow in terms of parameters and state variables, as a formula
  )
  %>% add_rate("E", "I", ~ (alpha))
  %>% add_rate("I", "R", ~ (gamma))     
)

## Set the error dist ----------
seir_obs_err = (seir
    %>% update_error_dist(
    S ~ poisson(),
    E ~ poisson(),
    I ~ poisson(),
    R ~ poisson()
  )
)
# for reproducibility
set.seed(15)

seir_obs_err_result = (seir_obs_err
  # turn on observation error in simluation
  %>% simulation_history(obs_error = TRUE)
)
## Add incidence --------
# update model to include incidence
seir_obs_err_inc = (seir_obs_err
  # add an expression to calculate in the simulation report
  %>% add_sim_report_expr("incidence", ~ (S_to_E) * (S))
  # add_error_dist instead of update_ because 
  # update_ replaces previously attached error distributions
  # add_ appends
  %>% add_error_dist( 
    incidence ~ poisson()
  )
)

seir_obs_err_inc_result = (seir_obs_err_inc
  %>% simulation_history(obs_error = TRUE)
)

observed = (
  seir_obs_err_inc_result
  %>% select(-matches("to"))
  %>% rename(date = Date)
  %>% pivot_longer(-date, names_to = "var")
  # keep incidence observations
  %>% filter(var == "incidence")
  # lob off first observation 
  # (fitting the initial value is technically difficult and not important to figure out here)
  %>% slice(-1)
)

observed <- observed %>%
  # slice(1:53) %>%
  mutate(value = obs$value)

# HERE IS THE CALIBRATION PART
seir_obs_err_inc_to_calibrate = (seir_obs_err_inc
  # attach observed data
  %>% update_observed(
    observed
  )
  # attach priors for parameters we're fitting
  # ("optimizing" over)
  %>% update_opt_params(
    # fitting log beta
    log_beta ~ log_normal(
      # -1, # log mean, so mean beta is exp(-1) = 0.36
      pars$log_m,
      pars$log_sd
      # 0.5 # standard deviation of the log normal prior
    )
  )
)

# Calibrate stan ---------
model_fit = calibrate_stan(
    model = seir_obs_err_inc, # original model object
    model_to_calibrate = seir_obs_err_inc_to_calibrate, # model object with observed data and priors
    chains = 2 # number of MCMC chains
)

## Stan output -------
fit = tidy_fit_stan(model_fit)$fit # a simple utility to attach parameter names to stan output
rstan::summary(fit)$summary
rstan::traceplot(fit, ncol = 1)

fit_ensemble_summary = (model_fit
  %>% ensemble_stan(n_cores = 4) # generate ensemble in parallel
  %>% summarise_ensemble_stan()
)

head(fit_ensemble_summary)

plot_ensemble(fit_ensemble_summary, observed)
```
## Generate ensemble

```{r}
fcst_ensemble_summary = (model_fit
  %>% ensemble_stan(
    days_to_forecast = 15, # new! number of days to forecast
    n_cores = 4
  )
  %>% summarise_ensemble_stan() # can specify a different quantile vector here: see documentation
)

plot_ensemble(fcst_ensemble_summary, observed, title = 'model with 14M pop')

# ggarrange(plotlist = fig)
```

This would be the distribution of beta

```{r}
rlnorm(n = 1000, meanlog = pars$log_m, sdlog = pars$log_sd) %>% hist()
```




